<!DOCTYPE html>
<html lang="en" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover">
    <title>TON Vesting Contracts - Validators Dashboard</title>
    <link rel="stylesheet" href="assets/validators.css">
</head>
<body>

<div class="container">
    <div class="header">
        <h1>TON Vesting Contracts</h1>
        <div class="subtitle">All Vesting contracts with sorting functionality</div>
        <div style="font-size: 12px; color: #666; margin-top: 5px; text-align: center;">
            üöÄ Page will display cached content immediately, then update missing data in background
        </div>
        <div class="nav-buttons">
            <a href="index.html" class="nav-button">
                üè† Validators
            </a>
            <a href="nominators.html" class="nav-button">
                üìä Nominators
            </a>
            <a href="vesting.html" class="nav-button active">
                üí∞ Vesting
            </a>
            <a href="tontech.html" class="nav-button">
                üî¨ TON Data
            </a>
            <a href="ktonviewer.html" class="nav-button">
                üîç LST Tool
            </a>
        </div>
    </div>

    <div id="statsContainer" class="stats-grid">
    </div>



    <div id="tableContainer">
    </div>
</div>



<div class="api-status" id="apiStatus">
    <div>Data Source: <span class="api-name" id="apiName">Tonscan API</span></div>
    <div class="api-performance" id="apiPerformance"></div>
</div>

<script>
    // Utility functions
    const fromNano = (nano) => {
            return BigInt(nano) / BigInt(1000000000);
    }

    const toMillions = (n) => {
        return (Number(n) / 1e6).toFixed(3) + 'M';
    }

    const toMillionsShort = (n) => {
        let s = (Number(n) / 1e6).toFixed(3);
        for (let i = 0; i < 3; i++) {
            if (s.endsWith('0')) s = s.substring(0, s.length - 1);
        }
        if (s.endsWith('.')) s = s.substring(0, s.length - 1);
        return s + 'M';
    }

    const withCommas = (n) => {
        try {
            const num = typeof n === 'bigint' ? Number(n) : Number(n);
            if (Number.isNaN(num)) return n;
            return num.toLocaleString('en-US');
        } catch {
            return n;
        }
    }

    const makeAddressUrl = (address) => {
        return `<a href="https://tonscan.org/address/${address}" target="_blank">${address}</a>`;
    }

    const showLoading = () => {
        // Loading indicator removed, no need to display
    }

    const hideLoading = () => {
        // Loading indicator removed, no need to hide
    }

    const updateProgress = (percentage, text = null) => {
        // Use API status panel to display progress
        if (text) {
            const progressText = `${Math.round(percentage)}% - ${text}`;
            updateApiStatus('Tonscan API', null, progressText, true);
            console.log(`Loading progress: ${Math.round(percentage)}% - ${text}`);
        }
    }

    const timestampToDate = (timestamp) => {
        const date = new Date(timestamp * 1000);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    }

    // Global variables
    let vestingData = [];
    let filteredData = [];
    let sortColumn = 'unvested'; // Default sort by unvested amount
    let sortDirection = 'desc'; // Default descending
    let labels = {}; // address -> label
    
    // TON Center API configuration
    const TONCENTER_API_KEY = '4ee76f835930b91d73f0906da03a3f6fdad65e7074ca2cb10271d73105d7530c';
    const TONCENTER_VESTING_URL = 'https://toncenter.com/api/v3/vesting';
    const API_RATE_LIMIT = TONCENTER_API_KEY ? 10 : 1; // requests per second
    const REQUEST_DELAY = 1000 / API_RATE_LIMIT; // milliseconds between requests
    
    // Cache for vesting details
    let vestingCache = {};
    let noDataCache = new Set(); // Track addresses with no vesting data
    let lastRequestTime = 0;
    let isPageRefresh = false; // Track if this is a page refresh
    
    // Load cache from localStorage on page load
    function loadCacheFromStorage() {
        try {
            const cachedVesting = localStorage.getItem('vestingCache');
            if (cachedVesting) {
                vestingCache = JSON.parse(cachedVesting);
                console.log(`üì¶ Loaded ${Object.keys(vestingCache).length} vesting contracts from localStorage cache`);
            }
            
            const cachedNoData = localStorage.getItem('noDataCache');
            if (cachedNoData) {
                const noDataArray = JSON.parse(cachedNoData);
                noDataCache = new Set(noDataArray);
                console.log(`üì¶ Loaded ${noDataCache.size} no-data addresses from localStorage cache`);
            }
        } catch (error) {
            console.warn('Error loading cache from localStorage:', error);
            // Reset cache on error
            vestingCache = {};
            noDataCache = new Set();
        }
    }
    
    // Save cache to localStorage
    function saveCacheToStorage() {
        try {
            localStorage.setItem('vestingCache', JSON.stringify(vestingCache));
            localStorage.setItem('noDataCache', JSON.stringify(Array.from(noDataCache)));
        } catch (error) {
            console.warn('Error saving cache to localStorage:', error);
        }
    }

    // API status updates
    function updateApiStatus(apiName, responseTime = null, progressText = null, keepVisible = false) {
        const apiStatus = document.getElementById('apiStatus');
        const apiNameElement = document.getElementById('apiName');
        const apiPerformance = document.getElementById('apiPerformance');

        apiNameElement.textContent = apiName;
        
        let performanceText = '';
        if (progressText) {
            performanceText = progressText;
        } else if (responseTime !== null) {
            performanceText = `${responseTime.toFixed(0)}ms`;
        }
        
        apiPerformance.textContent = performanceText;
        apiStatus.classList.add('show');
        
        // Clear previous timer
        if (window.apiStatusTimeout) {
            clearTimeout(window.apiStatusTimeout);
        }
        
        // Hide after 3 seconds if not keeping visible
        if (!keepVisible && !progressText) {
            window.apiStatusTimeout = setTimeout(() => {
                apiStatus.classList.remove('show');
            }, 3000);
        }
    }

    // Hide API status
    function hideApiStatus() {
        const apiStatus = document.getElementById('apiStatus');
        if (window.apiStatusTimeout) {
            clearTimeout(window.apiStatusTimeout);
        }
        apiStatus.classList.remove('show');
    }

    // Rate limiting utility
    async function waitForRateLimit() {
        const now = Date.now();
        const timeSinceLastRequest = now - lastRequestTime;
        if (timeSinceLastRequest < REQUEST_DELAY) {
            await new Promise(resolve => setTimeout(resolve, REQUEST_DELAY - timeSinceLastRequest));
        }
        lastRequestTime = Date.now();
    }

        // Fetch vesting contract details from TON Center API
    async function fetchVestingDetails(contractAddress, forceRefresh = false) {
        // Check cache first - return cached data if exists and not forcing refresh
        if (!forceRefresh && vestingCache[contractAddress]) {
            console.log(`Using cached vesting data for ${contractAddress}`);
            return vestingCache[contractAddress];
        }

        // If forcing refresh, remove from noDataCache to allow retry
        if (forceRefresh) {
            noDataCache.delete(contractAddress);
        }

        await waitForRateLimit();

        try {
            const url = `${TONCENTER_VESTING_URL}?contract_address=${encodeURIComponent(contractAddress)}`;
            const headers = {
                'Content-Type': 'application/json'
            };
            
            if (TONCENTER_API_KEY) {
                headers['X-API-Key'] = TONCENTER_API_KEY;
            }

                const response = await fetch(url, {
                method: 'GET',
                headers: headers
            });
                
                if (!response.ok) {
                console.warn(`API Error for ${contractAddress}: ${response.status}`);
                // Mark as no data for this session, but will retry on refresh
                noDataCache.add(contractAddress);
                
                // Save to localStorage
                saveCacheToStorage();
                
                return null;
                }
                
                const data = await response.json();
                
            // Check if we got valid vesting data
            if (!data.vesting_contracts || data.vesting_contracts.length === 0) {
                console.warn(`No vesting data found for ${contractAddress}`);
                // Mark as no data for this session, but will retry on refresh
                noDataCache.add(contractAddress);
                
                // Save to localStorage
                saveCacheToStorage();
                
                return null;
            }

            const vestingContract = data.vesting_contracts[0];
            const processedData = {
                address: vestingContract.address,
                start_time: vestingContract.start_time,
                total_duration: vestingContract.total_duration,
                unlock_period: vestingContract.unlock_period,
                cliff_duration: vestingContract.cliff_duration,
                sender_address: vestingContract.sender_address,
                owner_address: vestingContract.owner_address,
                total_amount: vestingContract.total_amount,
                whitelist: vestingContract.whitelist || [],
                            address_book: data.address_book || {}
                        };

            // Cache the successful result and remove from noDataCache
            vestingCache[contractAddress] = processedData;
            noDataCache.delete(contractAddress);
            
            // Save to localStorage
            saveCacheToStorage();
            
            console.log(`Successfully fetched and cached vesting data for ${contractAddress}`);
            return processedData;
                
            } catch (error) {
            console.error(`Failed to fetch vesting details for ${contractAddress}:`, error);
            // Mark as no data for this session, but will retry on refresh
            noDataCache.add(contractAddress);
            return null;
        }
    }

    // Calculate vesting status
    function calculateVestingStatus(vestingDetails, currentBalance) {
        if (!vestingDetails) return null;

        // Validate required fields
        if (!vestingDetails.total_amount || 
            !vestingDetails.start_time || 
            !vestingDetails.total_duration || 
            !vestingDetails.unlock_period || 
            !vestingDetails.cliff_duration) {
            console.warn('Incomplete vesting details:', vestingDetails);
            return null;
        }

        // Ensure all values are valid numbers
        const startTime = Number(vestingDetails.start_time);
        const totalDuration = Number(vestingDetails.total_duration);
        const unlockPeriod = Number(vestingDetails.unlock_period);
        const cliffDuration = Number(vestingDetails.cliff_duration);
        
        // Validate numeric values
        if (isNaN(startTime) || isNaN(totalDuration) || isNaN(unlockPeriod) || isNaN(cliffDuration)) {
            console.warn('Invalid numeric values in vesting details:', {
                startTime, totalDuration, unlockPeriod, cliffDuration
            });
            return null;
        }

        // Validate total_amount is a valid string or number
        let totalAmount;
        try {
            totalAmount = BigInt(vestingDetails.total_amount);
        } catch (error) {
            console.warn('Invalid total_amount:', vestingDetails.total_amount, error);
            return null;
        }

        const now = Math.floor(Date.now() / 1000);
        
        // Calculate vested amount
        let vestedAmount = BigInt(0);
        if (now >= startTime) {
            const elapsedTime = Math.min(now - startTime, totalDuration);
            
            if (elapsedTime >= cliffDuration && unlockPeriod > 0) {
                const vestingPeriods = Math.floor(elapsedTime / unlockPeriod);
                const totalPeriods = Math.floor(totalDuration / unlockPeriod);
                if (totalPeriods > 0) {
                    vestedAmount = totalAmount * BigInt(vestingPeriods) / BigInt(totalPeriods);
                }
            }
        }

        const unvestedAmount = totalAmount - vestedAmount;
        const liquidAmount = currentBalance - unvestedAmount > 0 ? currentBalance - unvestedAmount : BigInt(0);

        return {
            totalAmount,
            vestedAmount,
            unvestedAmount,
            liquidAmount,
            startTime,
            totalDuration,
            unlockPeriod,
            cliffDuration
        };
    }

    // Load labels from labels.csv
    async function fetchLabelsCsv() {
        try {
            updateApiStatus('Loading', null, 'Loading labels...', true);
            const response = await fetch('labels.csv');
            if (!response.ok) throw new Error('Failed to load labels.csv');
            const text = await response.text();
            const lines = text.split('\n');
            const columns = lines.map(line => line.split(','));
            columns.forEach(c => {
                if (c.length !== 2) return;
                const addr = c[0];
                const label = c[1].trim();
                if (label && label !== '#N/A') {
                    labels[addr] = label;
                }
            });
            updateApiStatus('Loading', null, `Loaded ${Object.keys(labels).length} labels`, false);
            if (filteredData && filteredData.length) {
                renderTable();
            }
                } catch (e) {
            console.warn('Failed to load labels.csv', e);
            updateApiStatus('Loading Failed', null, 'Failed to load labels', false);
                }
    }

    // Fetch all Vesting contract addresses
    async function fetchAllVestingAddresses() {
        const CODE_HASH = 'tItTGr7DtxRjgpH3137W3J9qJynvyiBHcTc3TUrotZA=';
        const BATCH_SIZE = 50;
        let allAddresses = [];
        let offset = 0;
        let hasMore = true;
        const maxEstimated = 500; // Estimated maximum count for progress calculation

        updateProgress(10, 'Fetching Vesting contract list...');

        while (hasMore && allAddresses.length < 500) {
            try {
                const url = `https://api.tonscan.com/api/bt/getAddressesForContract?code_hash=${encodeURIComponent(CODE_HASH)}&limit=${BATCH_SIZE}&offset=${offset}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Check API response structure
                if (!data.json || !data.json.data) {
                    console.warn('Unusual API response format:', data);
                    hasMore = false;
                    break;
                }
                
                const addresses = data.json.data;
                
                if (!Array.isArray(addresses) || addresses.length === 0) {
                    console.log(`No more data at offset ${offset}, ending fetch`);
                    hasMore = false;
                } else {
                    allAddresses = allAddresses.concat(addresses);
                    offset += BATCH_SIZE;
                    
                    // Update progress (10% - 70%)
                    const fetchProgress = Math.min(70, 10 + (allAddresses.length / maxEstimated) * 60);
                    updateProgress(fetchProgress, `Fetched ${allAddresses.length} Vesting contract addresses...`);
                    
                    console.log(`Fetched ${allAddresses.length} Vesting contract addresses...`);
                }
                
                // Avoid too frequent requests
                await new Promise(resolve => setTimeout(resolve, 100));
                
            } catch (error) {
                console.error(`Failed to fetch address list (offset: ${offset}):`, error);
                hasMore = false;
                break;
            }
        }

        updateProgress(80, 'Processing and sorting data...');
        console.log(`Total fetched ${allAddresses.length} Vesting contract addresses`);

        // Filter invalid data and sort by balance
        const validAddresses = allAddresses.filter(addr => 
            addr && addr.address && typeof addr.balance !== 'undefined'
        );
        
        updateProgress(90, 'Sorting contracts...');
        
        validAddresses.sort((a, b) => {
            try {
                return BigInt(b.balance) - BigInt(a.balance) > 0 ? 1 : -1;
            } catch (e) {
                console.warn('Invalid balance encountered during sorting:', a.balance, b.balance);
                return 0;
            }
        });
        
        updateProgress(100, 'Loading complete!');
        
        return validAddresses; // Return all addresses, no limit
    }

    // Render statistics
    function renderStats() {
        if (!vestingData || vestingData.length === 0) {
            document.getElementById('statsContainer').innerHTML = `
                <div class="stat-card">
                    <h3>Loading...</h3>
                    <p class="value">-</p>
                </div>
            `;
            return;
        }

        const totalContracts = vestingData.length;
        const totalBalance = vestingData.reduce((sum, contract) => {
            try {
                return sum + BigInt(contract.balance || 0);
            } catch (e) {
                console.warn('Invalid balance data:', contract.balance);
                return sum;
            }
        }, BigInt(0));
        
        const totalUnvestedAmount = vestingData.reduce((sum, contract) => {
            try {
                return sum + (contract.unvestedAmount || BigInt(0));
            } catch (e) {
                return sum;
            }
        }, BigInt(0));
        
        const totalVestingAmount = vestingData.reduce((sum, contract) => {
            try {
                return sum + (contract.totalVestingAmount || BigInt(0));
            } catch (e) {
                return sum;
            }
        }, BigInt(0));
        
        const totalLiquidAmount = vestingData.reduce((sum, contract) => {
            try {
                return sum + (contract.liquidAmount || BigInt(0));
            } catch (e) {
                return sum;
            }
        }, BigInt(0));

        const activeContracts = vestingData.filter(c => c.balance && Number(c.balance) > 0).length;
        const contractsWithVestingData = vestingData.filter(c => c.vestingDetails).length;

        document.getElementById('statsContainer').innerHTML = `
            <div class="stat-card">
                <h3>Total Contracts</h3>
                <p class="value">${withCommas(totalContracts)}</p>
            </div>
            <div class="stat-card">
                <h3>Active Contracts</h3>
                <p class="value">${withCommas(activeContracts)}</p>
            </div>
            <div class="stat-card">
                <h3>Total Balance</h3>
                <p class="value">${toMillionsShort(fromNano(totalBalance))} TON</p>
            </div>
            <div class="stat-card" style="background: rgba(255, 59, 48, 0.1); border: 2px solid rgba(255, 59, 48, 0.3);">
                <h3>Total Unvested Amount</h3>
                <p class="value" style="color: #FF3B30; font-weight: bold;">${toMillionsShort(fromNano(totalUnvestedAmount))} TON</p>
            </div>
            <div class="stat-card">
                <h3>Total Liquid Amount</h3>
                <p class="value" style="color: #34C759;">${toMillionsShort(fromNano(totalLiquidAmount))} TON</p>
            </div>
            <div class="stat-card">
                <h3>Total Vesting Amount</h3>
                <p class="value">${toMillionsShort(fromNano(totalVestingAmount))} TON</p>
            </div>
            <div class="stat-card">
                <h3>Contracts with Data</h3>
                <p class="value">${withCommas(contractsWithVestingData)} / ${withCommas(totalContracts)}</p>
                ${noDataCache.size > 0 ? `
                    <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; width: 100%;">
                        <button onclick="loadVestingData(true)" class="action-button update-button">
                            <span class="button-icon">üîÑ</span>
                            <span class="button-text">Background Update</span>
                            <span class="button-badge">${noDataCache.size}</span>
                        </button>
                        <button onclick="loadVestingData(true, true)" class="action-button reload-button">
                            <span class="button-icon">‚ö°</span>
                            <span class="button-text">Full Reload</span>
                        </button>
                    </div>
                ` : ''}
            </div>
        `;
    }

    // Sort function
    function sortData(column) {
        if (sortColumn === column) {
            // If clicking the same column, toggle sort direction
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            // If clicking different column, set new column and use default sort direction
            sortColumn = column;
            sortDirection = ['balance', 'unvested', 'totalVesting', 'liquid'].includes(column) ? 'desc' : 'asc';
        }
        
        filterData();
    }

    // Sort data
    function filterData() {
        let filtered = [...vestingData]; // Copy all data

        // Sort logic
        filtered.sort((a, b) => {
            let valueA, valueB;
            
            switch (sortColumn) {
                case 'rank':
                    valueA = vestingData.indexOf(a) + 1;
                    valueB = vestingData.indexOf(b) + 1;
                    break;
                case 'address':
                    valueA = a.address.toLowerCase();
                    valueB = b.address.toLowerCase();
                    break;
                case 'balance':
                    valueA = BigInt(a.balance || 0);
                    valueB = BigInt(b.balance || 0);
                    break;
                case 'unvested':
                    valueA = a.unvestedAmount || BigInt(0);
                    valueB = b.unvestedAmount || BigInt(0);
                    break;
                case 'totalVesting':
                    valueA = a.totalVestingAmount || BigInt(0);
                    valueB = b.totalVestingAmount || BigInt(0);
                    break;
                case 'liquid':
                    valueA = a.liquidAmount || BigInt(0);
                    valueB = b.liquidAmount || BigInt(0);
                    break;
                case 'owner':
                    valueA = (a.ownerAddress || '').toLowerCase();
                    valueB = (b.ownerAddress || '').toLowerCase();
                    break;
                case 'vestingStart':
                    valueA = a.vestingStartTime || 0;
                    valueB = b.vestingStartTime || 0;
                    break;
                case 'duration':
                    valueA = a.vestingDuration || 0;
                    valueB = b.vestingDuration || 0;
                    break;
                case 'created':
                    valueA = a.created_utime || 0;
                    valueB = b.created_utime || 0;
                    break;
                case 'lastTx':
                    valueA = a.latest_transaction_time || 0;
                    valueB = b.latest_transaction_time || 0;
                    break;
                default:
                    return 0;
            }
            
            if (['balance', 'unvested', 'totalVesting', 'liquid'].includes(sortColumn)) {
                // BigInt comparison
                const result = valueA - valueB;
                return sortDirection === 'asc' ? 
                    (result > 0 ? 1 : result < 0 ? -1 : 0) : 
                    (result > 0 ? -1 : result < 0 ? 1 : 0);
            } else {
                // General comparison
                if (valueA < valueB) return sortDirection === 'asc' ? -1 : 1;
                if (valueA > valueB) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            }
        });

        filteredData = filtered;
        renderTable();
    }

    // Get sort icon
    function getSortIcon(column) {
        if (sortColumn !== column) {
            return '<span class="sort-icon">‚ÜïÔ∏è</span>';
        }
        return sortDirection === 'asc' ? 
            '<span class="sort-icon active">‚Üë</span>' : 
            '<span class="sort-icon active">‚Üì</span>';
    }

    // Render table
    function renderTable() {
        const container = document.getElementById('tableContainer');
        
        // Desktop table
        let desktopHtml = `
            <table>
                <thead>
                    <tr>
                        <th onclick="sortData('rank')">
                            Rank ${getSortIcon('rank')}
                        </th>
                        <th onclick="sortData('address')">
                            Contract Address ${getSortIcon('address')}
                        </th>
                        <th>
                            Label
                        </th>
                        <th onclick="sortData('balance')">
                            Current Balance ${getSortIcon('balance')}
                        </th>
                        <th onclick="sortData('unvested')" style="background: rgba(255, 59, 48, 0.1);">
                            <strong>Unvested Amount</strong> ${getSortIcon('unvested')}
                        </th>
                        <th onclick="sortData('liquid')">
                            Liquid Amount ${getSortIcon('liquid')}
                        </th>
                        <th onclick="sortData('totalVesting')">
                            Total Vesting ${getSortIcon('totalVesting')}
                        </th>
                        <th onclick="sortData('owner')">
                            Owner Address ${getSortIcon('owner')}
                        </th>
                        <th onclick="sortData('vestingStart')">
                            Vesting Start ${getSortIcon('vestingStart')}
                        </th>
                        <th onclick="sortData('duration')">
                            Duration (days) ${getSortIcon('duration')}
                        </th>
                    </tr>
                </thead>
                <tbody>
        `;

        // Mobile cards
        let mobileHtml = '<div class="mobile-table">';

        filteredData.forEach((contract, index) => {
            // Ensure balance is valid
            const balance = contract.balance && !isNaN(contract.balance) ? fromNano(contract.balance) : BigInt(0);
            const balanceDisplay = Number(balance) === 0 ? '0' : toMillions(balance);
            const rank = vestingData.indexOf(contract) + 1;
            const label = labels[contract.address] || '';
            
            // Format vesting amounts with validation
            let unvestedDisplay = '0';
            let liquidDisplay = balanceDisplay;
            let totalVestingDisplay = '-';
            
            try {
                if (contract.unvestedAmount && contract.unvestedAmount !== BigInt(0)) {
                    unvestedDisplay = toMillions(fromNano(contract.unvestedAmount));
                }
                if (contract.liquidAmount && contract.liquidAmount !== BigInt(0)) {
                    liquidDisplay = toMillions(fromNano(contract.liquidAmount));
                }
                if (contract.totalVestingAmount && contract.totalVestingAmount !== BigInt(0)) {
                    totalVestingDisplay = toMillions(fromNano(contract.totalVestingAmount));
                }
            } catch (error) {
                console.warn('Error formatting vesting amounts:', error, contract);
                // Fallback to safe values
                unvestedDisplay = '0';
                liquidDisplay = balanceDisplay;
                totalVestingDisplay = '-';
            }
            
            // Format addresses
            const ownerAddressShort = contract.ownerAddress ? 
                contract.ownerAddress.substring(0, 8) + '...' + contract.ownerAddress.substring(contract.ownerAddress.length - 6) : '-';
            const ownerAddressLink = contract.ownerAddress ? makeAddressUrl(contract.ownerAddress) : '-';
            
            // Format dates with validation
            const vestingStartDate = contract.vestingStartTime && !isNaN(contract.vestingStartTime) ? 
                new Date(contract.vestingStartTime * 1000).toLocaleDateString() : '-';
            const durationDays = contract.vestingDuration && !isNaN(contract.vestingDuration) ? 
                Math.floor(contract.vestingDuration / (24 * 60 * 60)) : '-';
            
            // Desktop table row
            desktopHtml += `
                <tr>
                    <td><span class="badge badge-info">#${rank}</span></td>
                    <td class="mono">${makeAddressUrl(contract.address)}</td>
                    <td>${label ? `<span class="badge badge-label">${label}</span>` : '-'}</td>
                    <td><strong>${balanceDisplay} TON</strong></td>
                    <td style="background: rgba(255, 59, 48, 0.05);"><strong style="color: #FF3B30;">${unvestedDisplay} TON</strong></td>
                    <td><span style="color: #34C759;">${liquidDisplay} TON</span></td>
                    <td>${totalVestingDisplay} TON</td>
                    <td class="mono" style="font-size: 11px;">${ownerAddressLink}</td>
                    <td>${vestingStartDate}</td>
                    <td>${durationDays}</td>
                </tr>
            `;

            // Mobile card
            mobileHtml += `
                <div class="mobile-card">
                    <div class="mobile-card-header">
                        <div class="mobile-card-title">
                            Vesting Contract #${rank}
                        </div>
                        <div class="mobile-card-index">#${rank}</div>
                    </div>
                    <div class="mobile-card-content">
                        <div class="mobile-card-row">
                            <span class="mobile-card-label">Label:</span>
                            <span class="mobile-card-value">${label || '-'}</span>
                        </div>
                        <div class="mobile-card-row">
                            <span class="mobile-card-label">Current Balance:</span>
                            <span class="mobile-card-value"><strong>${balanceDisplay} TON</strong></span>
                        </div>
                        <div class="mobile-card-row" style="background: rgba(255, 59, 48, 0.05);">
                            <span class="mobile-card-label"><strong>Unvested Amount:</strong></span>
                            <span class="mobile-card-value"><strong style="color: #FF3B30;">${unvestedDisplay} TON</strong></span>
                        </div>
                        <div class="mobile-card-row">
                            <span class="mobile-card-label">Liquid Amount:</span>
                            <span class="mobile-card-value"><span style="color: #34C759;">${liquidDisplay} TON</span></span>
                        </div>
                        <div class="mobile-card-row">
                            <span class="mobile-card-label">Total Vesting:</span>
                            <span class="mobile-card-value">${totalVestingDisplay} TON</span>
                        </div>
                        <div class="mobile-card-row">
                            <span class="mobile-card-label">Contract Address:</span>
                            <span class="mobile-card-value mono">${makeAddressUrl(contract.address)}</span>
                        </div>
                        <div class="mobile-card-row">
                            <span class="mobile-card-label">Owner Address:</span>
                            <span class="mobile-card-value mono">${ownerAddressLink}</span>
                        </div>
                        <div class="mobile-card-row">
                            <span class="mobile-card-label">Vesting Start:</span>
                            <span class="mobile-card-value">${vestingStartDate}</span>
                        </div>
                        <div class="mobile-card-row">
                            <span class="mobile-card-label">Duration:</span>
                            <span class="mobile-card-value">${durationDays} days</span>
                        </div>
                    </div>
                </div>
            `;
        });

        desktopHtml += `
                </tbody>
            </table>
        `;

        mobileHtml += '</div>';

        container.innerHTML = desktopHtml + mobileHtml;
    }

    // Load vesting details for contracts - fast mode (cache only)
    function enrichVestingDataFromCache(contractsData) {
        const enrichedData = [];
        
        for (let i = 0; i < contractsData.length; i++) {
            const contract = contractsData[i];
            
            try {
                // Use cached data if available
                const vestingDetails = vestingCache[contract.address] || null;
                
                // Calculate vesting status
                const vestingStatus = calculateVestingStatus(vestingDetails, BigInt(contract.balance || 0));
                
                // Combine all data
                const enrichedContract = {
                    ...contract,
                    vestingDetails,
                    vestingStatus,
                    // Key metrics for easy access
                    totalVestingAmount: vestingStatus ? vestingStatus.totalAmount : BigInt(0),
                    unvestedAmount: vestingStatus ? vestingStatus.unvestedAmount : BigInt(0),
                    liquidAmount: vestingStatus ? vestingStatus.liquidAmount : BigInt(contract.balance || 0),
                    ownerAddress: vestingDetails ? vestingDetails.owner_address : null,
                    senderAddress: vestingDetails ? vestingDetails.sender_address : null,
                    vestingStartTime: vestingDetails ? vestingDetails.start_time : null,
                    vestingDuration: vestingDetails ? vestingDetails.total_duration : null,
                    unlockPeriod: vestingDetails ? vestingDetails.unlock_period : null
                };
                
                enrichedData.push(enrichedContract);
            } catch (error) {
                console.warn(`Error processing contract ${contract.address} from cache:`, error);
                
                // Add contract with fallback data
                const fallbackContract = {
                    ...contract,
                    vestingDetails: null,
                    vestingStatus: null,
                    totalVestingAmount: BigInt(0),
                    unvestedAmount: BigInt(0),
                    liquidAmount: BigInt(contract.balance || 0),
                    ownerAddress: null,
                    senderAddress: null,
                    vestingStartTime: null,
                    vestingDuration: null,
                    unlockPeriod: null
                };
                
                enrichedData.push(fallbackContract);
            }
        }
        
        return enrichedData;
    }
    
    // Background update for addresses without data
    async function updateMissingVestingData(contractsData, onProgress = null, onComplete = null) {
        const addressesToUpdate = [];
        
        // Find addresses that need updating
        for (const contract of contractsData) {
            const hasCache = vestingCache[contract.address];
            const wasNoData = noDataCache.has(contract.address);
            
            if (!hasCache || wasNoData) {
                addressesToUpdate.push(contract);
            }
        }
        
        if (addressesToUpdate.length === 0) {
            console.log('No addresses need updating');
            if (onComplete) onComplete(0);
            return;
        }
        
        console.log(`Background updating ${addressesToUpdate.length} addresses...`);
        
        let updatedCount = 0;
        let newDataCount = 0;
        
        for (let i = 0; i < addressesToUpdate.length; i++) {
            const contract = addressesToUpdate[i];
            
            try {
                const wasNoData = noDataCache.has(contract.address);
                const vestingDetails = await fetchVestingDetails(contract.address, wasNoData);
                
                if (vestingDetails && !vestingCache[contract.address]) {
                    newDataCount++;
                    console.log(`üéâ Found new vesting data for ${contract.address}`);
                }
                
                updatedCount++;
                
                if (onProgress) {
                    onProgress(updatedCount, addressesToUpdate.length, newDataCount);
                }
                
            } catch (error) {
                console.warn(`Background update failed for ${contract.address}:`, error);
                updatedCount++;
                
                if (onProgress) {
                    onProgress(updatedCount, addressesToUpdate.length, newDataCount);
                }
            }
        }
        
        if (onComplete) {
            onComplete(newDataCount);
        }
        
        console.log(`Background update complete: ${updatedCount}/${addressesToUpdate.length} processed, ${newDataCount} new data found`);
    }

    // Load vesting details for contracts - full mode
    async function enrichVestingData(contractsData, isRefresh = false) {
        const enrichedData = [];
        const totalContracts = contractsData.length;
        
        updateProgress(70, 'Fetching vesting contract details...');
        
        // Count addresses that need to be queried
        let addressesToQuery = 0;
        let queriedCount = 0;
        
        for (let i = 0; i < contractsData.length; i++) {
            const contract = contractsData[i];
            
            // Determine if we need to query this address
            const hasCache = vestingCache[contract.address];
            const wasNoData = noDataCache.has(contract.address);
            const needsQuery = !hasCache || (isRefresh && wasNoData);
            
            if (needsQuery) {
                addressesToQuery++;
            }
        }
        
        console.log(`Processing ${totalContracts} contracts. Need to query: ${addressesToQuery}, Using cache: ${totalContracts - addressesToQuery}`);
        
        for (let i = 0; i < contractsData.length; i++) {
            const contract = contractsData[i];
            
            try {
                // Determine if we need to query this address
                const hasCache = vestingCache[contract.address];
                const wasNoData = noDataCache.has(contract.address);
                const needsQuery = !hasCache || (isRefresh && wasNoData);
                
                let vestingDetails = null;
                
                if (needsQuery) {
                    queriedCount++;
                    updateProgress(
                        70 + (queriedCount / Math.max(addressesToQuery, 1)) * 20, 
                        `Querying ${queriedCount}/${addressesToQuery} addresses (${i + 1}/${totalContracts} total)...`
                    );
                    
                    // Fetch vesting details from TON Center API (force refresh if it was previously no data)
                    vestingDetails = await fetchVestingDetails(contract.address, wasNoData);
                } else if (hasCache) {
                    // Use cached data
                    vestingDetails = vestingCache[contract.address];
                }
                
                // Calculate vesting status
                const vestingStatus = calculateVestingStatus(vestingDetails, BigInt(contract.balance || 0));
                
                // Combine all data
                const enrichedContract = {
                    ...contract,
                    vestingDetails,
                    vestingStatus,
                    // Key metrics for easy access
                    totalVestingAmount: vestingStatus ? vestingStatus.totalAmount : BigInt(0),
                    unvestedAmount: vestingStatus ? vestingStatus.unvestedAmount : BigInt(0),
                    liquidAmount: vestingStatus ? vestingStatus.liquidAmount : BigInt(contract.balance || 0),
                    ownerAddress: vestingDetails ? vestingDetails.owner_address : null,
                    senderAddress: vestingDetails ? vestingDetails.sender_address : null,
                    vestingStartTime: vestingDetails ? vestingDetails.start_time : null,
                    vestingDuration: vestingDetails ? vestingDetails.total_duration : null,
                    unlockPeriod: vestingDetails ? vestingDetails.unlock_period : null
                };
                
                enrichedData.push(enrichedContract);
                
                // Update progress for processing
                if (!needsQuery) {
                    const progressPercent = 70 + (i + 1) / totalContracts * 25;
                    updateProgress(progressPercent, `Processing ${i + 1}/${totalContracts} contracts (using cache)...`);
                }
                
            } catch (error) {
                console.warn(`Error processing contract ${contract.address}:`, error);
                // Add contract without vesting details
                enrichedData.push({
                    ...contract,
                    vestingDetails: null,
                    vestingStatus: null,
                    totalVestingAmount: BigInt(0),
                    unvestedAmount: BigInt(0),
                    liquidAmount: BigInt(contract.balance || 0),
                    ownerAddress: null,
                    senderAddress: null,
                    vestingStartTime: null,
                    vestingDuration: null,
                    unlockPeriod: null
                });
            }
        }
        
        return enrichedData;
    }

    // Load data with fast cache display + background update
    async function loadVestingData(isRefresh = false, forceFullLoad = false) {
        try {
            console.log('Starting to fetch Vesting contract data...');
            
            // Check if we have cached data first
            const cachedCount = Object.keys(vestingCache).length;
            const noDataCount = noDataCache.size;
            
            // Always show cached data first if available (both refresh and first load)
            if (cachedCount > 0) {
                console.log('üöÄ Showing cached data immediately...');
                
                try {
                    // Show cached data first without waiting for addresses
                    const existingAddresses = Object.keys(vestingCache);
                    const cachedData = existingAddresses.map(address => {
                        const contract = { 
                            address,
                            balance: '0', // Default balance, will be updated when addresses are loaded
                            created_utime: 0,
                            latest_transaction_time: 0
                        };
                        return enrichVestingDataFromCache([contract])[0];
                    });
                    
                    if (cachedData.length > 0) {
                        vestingData = cachedData;
                        renderStats();
                        filterData();
                        
                        updateApiStatus('Cache', null, `Showing cached data (${cachedCount} contracts)`, true);
                    }
                } catch (error) {
                    console.warn('Error showing cached data immediately:', error);
                    // Continue with normal loading process
                }
            }
            
            showLoading();
            updateProgress(0, 'Starting to load Vesting contract data...');
            
            const startTime = performance.now();
            
            // Get all vesting contract addresses
            const addressData = await fetchAllVestingAddresses();
            if (!addressData || addressData.length === 0) {
                throw new Error('Unable to fetch any Vesting contract data');
            }
            
            console.log(`Cache status: ${cachedCount} with data, ${noDataCount} without data${isRefresh ? ' (refresh mode)' : ''}`);
            
            // If we have cache, show cached data first and then background update
            if (cachedCount > 0) {
                console.log('üöÄ Fast loading from cache...');
                updateProgress(70, 'Loading from cache...');
                
                // Quick load from cache
                const cachedData = enrichVestingDataFromCache(addressData);
                vestingData = cachedData;
                
                updateProgress(95, 'Cache loaded, starting background update...');
                
                const fastEndTime = performance.now();
                console.log(`Fast cache load completed in ${(fastEndTime - startTime).toFixed(0)}ms`);
                
                // Show cached data immediately
                renderStats();
                filterData();
                
                // Update API status to show cache load
                updateApiStatus('Cache', fastEndTime - startTime, `Cache loaded (${cachedCount} contracts with data)`, true);
                
                // Start background update for missing data
                const addressesToUpdate = addressData.filter(contract => 
                    !vestingCache[contract.address] || noDataCache.has(contract.address)
                );
                
                if (addressesToUpdate.length > 0) {
                    console.log(`üîÑ Starting background update for ${addressesToUpdate.length} addresses...`);
                    
                    updateMissingVestingData(addressData, 
                        // Progress callback
                        (current, total, newDataFound) => {
                            const progressText = `Background update: ${current}/${total} (found ${newDataFound} new data)`;
                            updateApiStatus('Background Update', null, progressText, true);
                        },
                        // Complete callback
                        (newDataFound) => {
                            console.log('üéâ Background update completed');
                            
                            if (newDataFound > 0) {
                                // Refresh display with new data
                                const updatedData = enrichVestingDataFromCache(addressData);
                                vestingData = updatedData;
                                renderStats();
                                filterData();
                                
                                updateApiStatus('Background Complete', null, `Background update complete! Found ${newDataFound} new data`, false);
                                
                                setTimeout(() => {
                                    hideApiStatus();
                                }, 5000);
                            } else {
                                // Even if no new data, refresh display to show updated contract info
                                const updatedData = enrichVestingDataFromCache(addressData);
                                vestingData = updatedData;
                                renderStats();
                                filterData();
                                
                                updateApiStatus('Background Complete', null, 'Background update complete, no new data found', false);
                                
                                setTimeout(() => {
                                    hideApiStatus();
                                }, 3000);
                            }
                        }
                    );
                } else {
                    setTimeout(() => {
                        hideApiStatus();
                    }, 3000);
                }
                
                // IMPORTANT: Return early when using cache to avoid calling enrichVestingData
                return;
                
            } else {
                // Standard full load when no cache available
                console.log('üì¶ Standard loading (no cache available)...');
                
                const enrichedData = await enrichVestingData(addressData, isRefresh);
                
                const endTime = performance.now();
                
                vestingData = enrichedData;
                console.log(`Successfully fetched and processed ${vestingData.length} Vesting contracts`);
                
                updateProgress(100, 'Complete!');
                
                // Show result after completion
                const newCachedCount = Object.keys(vestingCache).length;
                const newNoDataCount = noDataCache.size;
                const completionText = `Complete! Loaded ${vestingData.length} contracts (Cached: ${newCachedCount}, No data: ${newNoDataCount}) - ${(endTime - startTime).toFixed(0)}ms`;
                updateApiStatus('TON Center API', endTime - startTime, completionText, false);
                
                renderStats();
                filterData();
                
                setTimeout(() => {
                    hideApiStatus();
                }, 3000);
            }
            
        } catch (error) {
            console.error('Loading Vesting data failed:', error);
            
            // Show error status
            updateApiStatus('Loading Failed', null, error.message || 'Unable to load data', false);
            
            // Show friendly error message
            document.getElementById('statsContainer').innerHTML = `
                <div class="stat-card" style="grid-column: 1 / -1;">
                    <h3>Loading Failed</h3>
                    <p class="value" style="color: #FF3B30; font-size: 16px;">
                        ${error.message || 'Unable to load Vesting contract data'}
                    </p>
                    <button onclick="loadVestingData(true, true)" class="action-button retry-button">
                        <span class="button-icon">üîÑ</span>
                        <span class="button-text">Retry</span>
                    </button>
                </div>
            `;
            
            document.getElementById('tableContainer').innerHTML = '';
            
            setTimeout(() => {
                hideApiStatus();
            }, 5000);
        }
    }

    // Event listeners

    // Detect if this is a page refresh
    function detectPageRefresh() {
        // Check if there's any existing data that would indicate this is a refresh
        const hasExistingCache = Object.keys(vestingCache).length > 0;
        const hasExistingNoDataCache = noDataCache.size > 0;
        
        // Check performance navigation API if available
        let navigationTypeRefresh = false;
        if (performance.navigation) {
            navigationTypeRefresh = performance.navigation.type === performance.navigation.TYPE_RELOAD;
        } else if (performance.getEntriesByType) {
            const perfEntries = performance.getEntriesByType('navigation');
            if (perfEntries.length > 0) {
                navigationTypeRefresh = perfEntries[0].type === 'reload';
            }
        }
        
        isPageRefresh = navigationTypeRefresh || hasExistingCache || hasExistingNoDataCache;
        console.log(`Page load detected: ${isPageRefresh ? 'Refresh' : 'First load'}`);
        
        return isPageRefresh;
    }

    // Initialization
    document.addEventListener('DOMContentLoaded', () => {
        // Load cache from localStorage first
        loadCacheFromStorage();
        
        detectPageRefresh();
        fetchLabelsCsv();
        
        // Always try to show cached data first, then load/update
        const cachedCount = Object.keys(vestingCache).length;
        if (cachedCount > 0) {
            console.log('üöÄ Found existing cache on page load, showing immediately...');
            try {
                const existingAddresses = Object.keys(vestingCache);
                const cachedData = existingAddresses.map(address => {
                    const contract = { 
                        address,
                        balance: '0', // Default balance, will be updated when addresses are loaded
                        created_utime: 0,
                        latest_transaction_time: 0
                    };
                    return enrichVestingDataFromCache([contract])[0];
                });
                
                if (cachedData.length > 0) {
                    vestingData = cachedData;
                    renderStats();
                    filterData();
                    
                    updateApiStatus('Cache', null, `Showing cached data (${cachedCount} contracts)`, true);
                }
            } catch (error) {
                console.warn('Error showing cached data on page load:', error);
            }
        }
        
        loadVestingData(isPageRefresh);
    });

</script>

<style>
    .badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
        text-align: center;
        min-width: 30px;
    }

    .badge-info {
        background: linear-gradient(135deg, #007AFF, #5856D6);
        color: white;
    }

    .api-status {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        color: white;
        padding: 12px 16px;
        border-radius: 12px;
        font-size: 12px;
        z-index: 1001;
        display: none;
        min-width: 250px;
        max-width: 350px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .api-status.show {
        display: block;
        animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(100%);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    .api-status .api-name {
        font-weight: 600;
        color: #34C759;
    }

    .api-status .api-performance {
        font-size: 11px;
        opacity: 0.9;
        margin-top: 4px;
        word-wrap: break-word;
        white-space: normal;
        line-height: 1.4;
    }

    /* Responsive design for API status */
    @media (max-width: 768px) {
        .api-status {
            top: 10px;
            right: 10px;
            left: 10px;
            min-width: unset;
            max-width: unset;
            width: auto;
            font-size: 11px;
            padding: 10px 12px;
        }
        
        .api-status .api-performance {
            font-size: 10px;
        }
    }



    /* Table container styles - theme compliant */
    #tableContainer {
        overflow-x: auto;
        margin: 0;
        box-shadow: none;
        border: none;
        width: 100%;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
    }

    /* Basic table styles - theme compliant */
    table {
        width: 100%;
        min-width: 1400px;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 13px;
        background: transparent;
    }

    /* Table header styles - theme compliant */
    thead {
        background: rgba(248, 249, 250, 0.8);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        position: sticky;
        top: 0;
        z-index: 10;
    }

    /* Table title styles - theme compliant */
    th {
        padding: 18px 12px;
        text-align: left;
        font-weight: 600;
        font-size: 12px;
        color: #1d1d1f;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        white-space: nowrap;
        transition: all 0.2s ease;
        cursor: pointer;
        user-select: none;
        position: relative;
    }

    th:hover {
        background: rgba(0, 122, 255, 0.05);
    }

    /* Sort icon styles - theme compliant */
    .sort-icon {
        margin-left: 8px;
        font-size: 12px;
        color: #8E8E93;
        transition: color 0.2s ease;
    }

    .sort-icon.active {
        color: #007AFF;
        font-weight: bold;
    }

    /* Table data row styles - theme compliant */
    td {
        padding: 16px 12px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.04);
        white-space: nowrap;
        font-size: 13px;
        color: #1d1d1f;
    }

    tr:hover td {
        background-color: rgba(0, 122, 255, 0.02);
    }

    /* Responsive design - theme compliant */
    @media (max-width: 768px) {
        #tableContainer {
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
        }
        
        table {
            display: none;
        }
        
        .mobile-table {
            display: block;
        }
    }

    @media (min-width: 769px) {
        .mobile-table {
            display: none;
        }
    }

    /* Action Button Styles */
    .action-button {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 10px 14px;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 600;
        text-decoration: none;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        position: relative;
        overflow: hidden;
        min-height: 40px;
        max-width: 100%;
        box-sizing: border-box;
    }

    .action-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    }

    .action-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .action-button:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.3);
    }

    .button-icon {
        font-size: 16px;
        line-height: 1;
    }

    .button-text {
        white-space: nowrap;
    }

    .button-badge {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 11px;
        font-weight: 700;
        min-width: 18px;
        text-align: center;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        flex-shrink: 0;
        margin-left: auto;
    }

    /* Update Button (Green) */
    .update-button {
        background: linear-gradient(135deg, #34C759, #30D158);
        color: white;
        border: 1px solid rgba(52, 199, 89, 0.3);
    }

    .update-button:hover {
        background: linear-gradient(135deg, #30D158, #2ECC71);
        border-color: rgba(52, 199, 89, 0.5);
    }

    /* Reload Button (Blue) */
    .reload-button {
        background: linear-gradient(135deg, #007AFF, #5856D6);
        color: white;
        border: 1px solid rgba(0, 122, 255, 0.3);
    }

    .reload-button:hover {
        background: linear-gradient(135deg, #5856D6, #007AFF);
        border-color: rgba(0, 122, 255, 0.5);
    }

    /* Retry Button (Orange) */
    .retry-button {
        background: linear-gradient(135deg, #FF9500, #FF6B35);
        color: white;
        border: 1px solid rgba(255, 149, 0, 0.3);
    }

    .retry-button:hover {
        background: linear-gradient(135deg, #FF6B35, #FF9500);
        border-color: rgba(255, 149, 0, 0.5);
    }

    /* Responsive button design */
    @media (max-width: 768px) {
        .action-button {
            padding: 12px 16px;
            font-size: 14px;
            min-height: 48px;
            gap: 8px;
        }
        
        .button-icon {
            font-size: 18px;
        }
        
        .button-badge {
            font-size: 12px;
            padding: 3px 8px;
            min-width: 20px;
        }
    }

    /* Extra small screens */
    @media (max-width: 480px) {
        .action-button {
            padding: 10px 12px;
            font-size: 13px;
            min-height: 44px;
            gap: 6px;
        }
        
        .button-text {
            font-size: 12px;
        }
        
        .button-badge {
            font-size: 11px;
            padding: 2px 6px;
            min-width: 18px;
        }
    }


</style>

</body>
</html>

